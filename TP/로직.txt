

#변수저장 자료구조
- 변수의 값 : 상수, quote리스트, lambda(함수)
- 변수의 값으로 lambda가 들어오면
1) varTable에는 'lambda_함수명(=함수테이블 = funcTable)'테이블이 저장된다.
2) 함수 테이블에 요소는
   - expr : lambda리스트(함수)
   - var0 : 매개변수0
   - var1 : 매개변수1
   *지역변수는 존재하지 않는다는 가정이므로, 매개변수만 함주의 지역변수로 가정한다.
    따라서 함수 정의시 함수에서 사용될 지역변수들을 파악할 수 있고 이를 정적으로 딕셔너리에 저장한다.
    (지역변수 정의 불가이므로, 코드 실행 도중 함수 내부에서 변수가 동적으로 정의되지 않는다.)
★scope => SSR이랑 비슷하게 구현하려 했음
만약 lambda함수에서 변수를 사용할 경우
1) 자신의 lambda_함수명 테이블에서 변수를 찾음
2) None이 나올 경우 자신의 부모 테이블에서 변수를 찾음
3) 마지막 부모 테이블까지 변수를 찾았는데 없으면 정의되지 않은 변수이므로 에러 출력


#var_def 함수
- define키워드 들어오면 변수를 저장 ex) (define 변수명 값)
- 값이 될 수 있는것들
1. 상수(ex 1)
2. quote리스트 ('(1 2 3))
* 연산도 올 수 있음 => runExpr로 연산 처리 후 결과를 삽입(결론적으로 상수 삽입)
- 같은 이름의 변수를 정의하면 먼저 정의한 값 대체

라인 540 var_def
라인 579

라인 705 varTable

#var_get(변수명) 함수
- 찾고자하는 변수명을 인자로 받음
- varTable을 조사해서 변수에 해당하는 '값'을 return하는 함수
- 해당 변수가 없을 경우 None를 반환

#var_get
 변수를 가져오는 함수
- 변수의 값 return
- 변수의 값이 quote list인 경우 quote list반환

#변수 사용
- 이항연산 : 각 항의 타입이 ID이면 var_get함수를 호출해 변수의 값을 가져옴


<함수>
1. 함수 define
#make_func_table(node)
(lambda (x y) (+ x y))형태를 전달받아, function table을 return하는 함수
==> function table : ordered dictionary자료형
expr : 함수식 ex) (lambda (x y) (+ x y))
매개변수1 
매개변수 2
..
- 매개변수의 값은 None으로 저장됨
- 만들어진 function table은 var_def에 의해 varTable에 저장

2. 함수 실행
- 우선 run_func를 수정했음
run_func는 함수명과 함수를 기록한 테이블을 가지고 있으며,
op_code_node(연산자노드)를 받아서 테이블에서 해당하는 함수를 실행해서 그 결과를 return함
이것을
1) 테이블에 해당 operation이 있는 경우(cons,cdr,eq?같이 기본적으로 제공되는 연산인 경우)
    - 기존과 마찬가지로 동작함. 테이블에서 해당 operation 함수를 찾아서 실행 후, 그 결과를 반환.
2) 테이블에 해당 operation이 없는 경우(define으로 정의한 사용자 정의 함수인 경우)
    - run_user_func를 실행한 결과를 반환함

- #run_user_func(함수명,lambda의 인자 노드)
   1) varTable에서 함수를 찾음
   2) 함수표현에 인자를 붙여 노드로 만들어서 lambda 식을 만듬
   ex) 함수 : (lambda (x y) (+ x y)
         인자 : 1 2
         lambda식 : (lambda (x y) (+ x y) 1 2)
   3) lam호출해서 결과값 반환

- #lam(노드, 함수명)
*두가지 경우를 생각할 수 있음
case1] 사용자가 lambda식을 콘솔에 입력한 경우
case2] define을 이용해 lambda를 정의하고, 그 이후에 변수명을 통해 호출한 경우
1) case1처리 부분.
lam메소드에 '함수명'파라미터를 전달하지 않은 경우 case1이다.
(변수명을 통해 호출한 경우 run_user_func에 의해 함수명 파라미터가 넘어온다.)
두가지 경우를 동일하게 처리하기 위해 case1인 경우 함수명이 null인 함수를 정의한 것으로 간주한다.
(이를 위해 define문에 함수 이름을 null로 정의하지 못하도록 하는 코드를 추가했다.)
* 함수의 인자로 함수를 사용하는 등 여러개의 null함수가 필요한 경우가 있다.
이 경우 함수들이 null함수 테이블을 공유하게 되면 인자가 제대로 바인딩되지 않는 문제가 발생한다.
가령, 첫번째 null이 실행될 때 x = 10으로 바인딩했는데,
이 null이 실행되는 도중 또 다른 이름없는 함수를 만나 x=5로 바인딩하면
첫번째에 바인딩했던 x=10을 잃게 된다.
따라서 null1, null2.. 이런식으로 null뒤에 숫자를 붙여 각각의 null함수들을 구분해준다.
2) actual parameter바인딩
3) 함수 몸체(실제 처리될 연산) 노드들을 분리해서 따로 노드로 만듬
4) 함수명 funcStack에 push
5) 함수 몸체를 run_expr
6) 함수명 funcStack에서 pop
7) 바인딩된 파라미터 초기화 (null함수인 경우 함수 자체를 삭제)
8) 결과값 return

#18번(함수 인자로 함수를 사용하는 경우)
- lambda에서 매개변수 바인딩하는 부분을 수정했다.
- 매개변수를 바인딩할때 인자가 변수로 전달된 경우는 var_get(변수명)으로 변수의 값을 가져온다.
만약, 전달된 인자가 함수라면 var_get을 통해 해당하는 이름의 함수 테이블을 받아오게 된다.
그리고 이 함수 테이블을 인자로 매개변수에 바인딩 해준다.

#20번 (중첩)
- 외부의 함수를 '부모 함수', 내부의 함수를 '자식 함수'라고 하겠음
- 지역변수 선언은 없다고 가정되기 때문에, 
lambda식 내부에서 define을 만나면 nasted함수임

[1] var_def 마지막 부분에서
테이블에 식을 저장하기 전에,
식에 define이 있는지 확인 및 필드 추가
- define이 있다면 중첩함수.
- 함수 테이블에 nasted필드를 추가함 (nasted : true)
   --> 'nasted in 함수테이블명'이 true이면 중첩 부모함수임.
[2] run_user_func에서 nasted여부 확인
   nasted필드가 있다면 일반 lambda와 다르게 처리
   1) var_def를 호출해 자식함수 define수행
   2) 원래 식(expr)에서 define부분을 빼버림.
       define은 수행했으므로, 실질적으로 수행할 문장들만 남겨놓는 것임.
   ex) 20번 예제의 경우 cube함수에서 define부분을 빼버림
[3] [2]번 과정을 거치면 함수 내부에서 전역함수 호출하는 lambda함수 형태가 됨.
      따라서 lam호출해서 처리하면 됨.